//
//  Adobe Downloader
//
//  Created by X1a0He on 2024/10/30.
//

import SwiftUI
import Sparkle
import Combine


private enum AboutViewConstants {
    static let appIconSize: CGFloat = 96
    static let titleFontSize: CGFloat = 18
    static let subtitleFontSize: CGFloat = 14
    static let linkFontSize: CGFloat = 14
    static let licenseFontSize: CGFloat = 12
    
    static let verticalSpacing: CGFloat = 12
    static let formPadding: CGFloat = 8
    
    static let links: [(title: String, url: String)] = [
        ("@X1a0He", "https://t.me/X1a0He"),
        ("Github: Adobe Downloader", "https://github.com/X1a0He/Adobe-Downloader"),
        ("Drovosek01: adobe-packager", "https://github.com/Drovosek01/adobe-packager"),
        ("QiuChenly: InjectLib", "https://github.com/QiuChenly/InjectLib")
    ]
}

struct ExternalLinkView: View {
    let title: String
    let url: String
    
    var body: some View {
        Link(title, destination: URL(string: url)!)
            .font(.system(size: AboutViewConstants.linkFontSize))
            .foregroundColor(.blue)
    }
}

struct AboutView: View {
    private let updater: SPUUpdater
    
    init(updater: SPUUpdater) {
        self.updater = updater
    }
    
    var body: some View {
        TabView {
            GeneralSettingsView(updater: updater)
                .tabItem {
                    Label("ÈÄöÁî®", systemImage: "gear")
                }
                .id("general_settings")
            
            AboutAppView()
                .tabItem {
                    Label("ÂÖ≥‰∫é", systemImage: "info.circle")
                }
                .id("about_app")
        }
        .background(Color(NSColor.windowBackgroundColor))
        .frame(width: 600)
    }
}

struct AboutAppView: View {
    private var appVersion: String {
        Bundle.main.infoDictionary?["CFBundleShortVersionString"] as? String ?? "Unknown"
    }
    
    var body: some View {
        VStack(spacing: AboutViewConstants.verticalSpacing) {
            appIconSection
            appInfoSection
            linksSection
            licenseSection
        }
        .padding()
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
    
    private var appIconSection: some View {
        Image(nsImage: NSApp.applicationIconImage)
            .resizable()
            .frame(width: AboutViewConstants.appIconSize, height: AboutViewConstants.appIconSize)
    }
    
    private var appInfoSection: some View {
        Group {
            Text("Adobe Downloader \(appVersion)")
                .font(.system(size: AboutViewConstants.titleFontSize))
                .bold()
            
            Text("By X1a0He. ‚ù§Ô∏è Love from China. üá®üá≥")
                .font(.system(size: AboutViewConstants.subtitleFontSize))
                .foregroundColor(.secondary)
        }
    }
    
    private var linksSection: some View {
        ForEach(AboutViewConstants.links, id: \.url) { link in
            ExternalLinkView(title: link.title, url: link.url)
        }
    }
    
    private var licenseSection: some View {
        Text("GNUÈÄöÁî®ÂÖ¨ÂÖ±ËÆ∏ÂèØËØÅGPL v3.")
            .font(.system(size: AboutViewConstants.licenseFontSize))
            .foregroundColor(.secondary)
    }
}

struct PulsingCircle: View {
    let color: Color
    @State private var scale: CGFloat = 1.0
    
    var body: some View {
        Circle()
            .fill(color)
            .frame(width: 8, height: 8)
            .scaleEffect(scale)
            .animation(
                Animation.easeInOut(duration: 1.0)
                    .repeatForever(autoreverses: true),
                value: scale
            )
            .onAppear {
                scale = 1.5
            }
    }
}

final class GeneralSettingsViewModel: ObservableObject {
    @Published var setupVersion: String = ""
    @Published var isDownloadingSetup = false
    @Published var setupDownloadProgress = 0.0
    @Published var setupDownloadStatus = ""
    @Published var showAlert = false
    @Published var alertMessage = ""
    @Published var isSuccess = false
    @Published var showDownloadAlert = false
    @Published var showLanguagePicker = false
    @Published var showDownloadConfirmAlert = false
    @Published var showReprocessConfirmAlert = false
    @Published var isProcessing = false
    @Published var helperConnectionStatus: HelperConnectionStatus = .disconnected
    @Published var downloadAppleSilicon: Bool {
        didSet {
            StorageData.shared.downloadAppleSilicon = downloadAppleSilicon
        }
    }

    var defaultLanguage: String {
        get { StorageData.shared.defaultLanguage }
        set { StorageData.shared.defaultLanguage = newValue }
    }
    
    var defaultDirectory: String {
        get { StorageData.shared.defaultDirectory }
        set { StorageData.shared.defaultDirectory = newValue }
    }
    
    var useDefaultLanguage: Bool {
        get { StorageData.shared.useDefaultLanguage }
        set { StorageData.shared.useDefaultLanguage = newValue }
    }
    
    var useDefaultDirectory: Bool {
        get { StorageData.shared.useDefaultDirectory }
        set { StorageData.shared.useDefaultDirectory = newValue }
    }
    
    var confirmRedownload: Bool {
        get { StorageData.shared.confirmRedownload }
        set { 
            StorageData.shared.confirmRedownload = newValue
            objectWillChange.send()
        }
    }

    @Published var automaticallyChecksForUpdates: Bool
    @Published var automaticallyDownloadsUpdates: Bool

    @Published var isCancelled = false

    private var cancellables = Set<AnyCancellable>()
    let updater: SPUUpdater

    enum HelperConnectionStatus {
        case connected
        case connecting
        case disconnected
        case checking
    }

    init(updater: SPUUpdater) {
        self.updater = updater
        self.automaticallyChecksForUpdates = updater.automaticallyChecksForUpdates
        self.automaticallyDownloadsUpdates = updater.automaticallyDownloadsUpdates
        self.downloadAppleSilicon = StorageData.shared.downloadAppleSilicon
        
        self.helperConnectionStatus = .connecting
        
        PrivilegedHelperManager.shared.$connectionState
            .receive(on: DispatchQueue.main)
            .sink { [weak self] state in
                switch state {
                case .connected:
                    self?.helperConnectionStatus = .connected
                case .disconnected:
                    self?.helperConnectionStatus = .disconnected
                case .connecting:
                    self?.helperConnectionStatus = .connecting
                }
            }
            .store(in: &cancellables)
        
        PrivilegedHelperManager.shared.executeCommand("whoami") { _ in }
        
        NotificationCenter.default.publisher(for: .storageDidChange)
            .receive(on: RunLoop.main)
            .sink { [weak self] _ in
                self?.objectWillChange.send()
            }
            .store(in: &cancellables)
    }

    deinit {
        cancellables.removeAll()
    }

    func updateAutomaticallyChecksForUpdates(_ newValue: Bool) {
        automaticallyChecksForUpdates = newValue
        updater.automaticallyChecksForUpdates = newValue
    }

    func updateAutomaticallyDownloadsUpdates(_ newValue: Bool) {
        automaticallyDownloadsUpdates = newValue
        updater.automaticallyDownloadsUpdates = newValue
    }

    var isAutomaticallyDownloadsUpdatesDisabled: Bool {
        !automaticallyChecksForUpdates
    }

    func cancelDownload() {
        isCancelled = true
    }
}

struct GeneralSettingsView: View {
    @StateObject private var viewModel: GeneralSettingsViewModel
    @State private var showHelperAlert = false
    @State private var helperAlertMessage = ""
    @State private var helperAlertSuccess = false
    @EnvironmentObject private var networkManager: NetworkManager

    init(updater: SPUUpdater) {
        _viewModel = StateObject(wrappedValue: GeneralSettingsViewModel(updater: updater))
    }

    var body: some View {
        Form {
            DownloadSettingsView(viewModel: viewModel)
            HelperSettingsView(viewModel: viewModel,
                            showHelperAlert: $showHelperAlert,
                            helperAlertMessage: $helperAlertMessage,
                            helperAlertSuccess: $helperAlertSuccess)
            CCSettingsView(viewModel: viewModel)
            UpdateSettingsView(viewModel: viewModel)
            CleanConfigView()
        }
        .padding()
        .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
        .alert(helperAlertSuccess ? "Êìç‰ΩúÊàêÂäü" : "Êìç‰ΩúÂ§±Ë¥•", isPresented: $showHelperAlert) {
            Button("Á°ÆÂÆö") { }
        } message: {
            Text(helperAlertMessage)
        }
        .alert("ÈúÄË¶Å‰∏ãËΩΩ Setup ÁªÑ‰ª∂", isPresented: $viewModel.showDownloadAlert) {
            Button("ÂèñÊ∂à", role: .cancel) { }
            Button("‰∏ãËΩΩ") {
                Task {
                    viewModel.isDownloadingSetup = true
                    viewModel.isCancelled = false
                    do {
                        try await networkManager.downloadUtils.downloadX1a0HeCCPackages(
                            progressHandler: { progress, status in
                                viewModel.setupDownloadProgress = progress
                                viewModel.setupDownloadStatus = status
                            },
                            cancellationHandler: { viewModel.isCancelled }
                        )
                        viewModel.setupVersion = ModifySetup.checkComponentVersion()
                        viewModel.isSuccess = true
                        viewModel.alertMessage = "Setup ÁªÑ‰ª∂ÂÆâË£ÖÊàêÂäü"
                    } catch NetworkError.cancelled {
                        viewModel.isSuccess = false
                        viewModel.alertMessage = String(localized: "‰∏ãËΩΩÂ∑≤ÂèñÊ∂à")
                    } catch {
                        viewModel.isSuccess = false
                        viewModel.alertMessage = error.localizedDescription
                    }
                    viewModel.showAlert = true
                    viewModel.isDownloadingSetup = false
                }
            }
        } message: {
            Text("Ê£ÄÊµãÂà∞Á≥ªÁªü‰∏≠‰∏çÂ≠òÂú® Setup ÁªÑ‰ª∂ÔºåÈúÄË¶ÅÂÖà‰∏ãËΩΩÁªÑ‰ª∂ÊâçËÉΩÁªßÁª≠Êìç‰Ωú„ÄÇ")
        }
        .alert("Á°ÆËÆ§‰∏ãËΩΩ", isPresented: $viewModel.showDownloadConfirmAlert) {
            Button("ÂèñÊ∂à", role: .cancel) { }
            Button("Á°ÆÂÆö") {
                Task {
                    viewModel.isDownloadingSetup = true
                    viewModel.isCancelled = false
                    do {
                        try await networkManager.downloadUtils.downloadX1a0HeCCPackages(
                            progressHandler: { progress, status in
                                viewModel.setupDownloadProgress = progress
                                viewModel.setupDownloadStatus = status
                            },
                            cancellationHandler: { viewModel.isCancelled }
                        )
                        viewModel.setupVersion = ModifySetup.checkComponentVersion()
                        viewModel.isSuccess = true
                        viewModel.alertMessage = String(localized: "Setup ÁªÑ‰ª∂ÂÆâË£ÖÊàêÂäü")
                    } catch NetworkError.cancelled {
                        viewModel.isSuccess = false
                        viewModel.alertMessage = String(localized: "‰∏ãËΩΩÂ∑≤ÂèñÊ∂à")
                    } catch {
                        viewModel.isSuccess = false
                        viewModel.alertMessage = error.localizedDescription
                    }
                    viewModel.showAlert = true
                    viewModel.isDownloadingSetup = false
                }
            }
        } message: {
            Text("Á°ÆÂÆöË¶Å‰∏ãËΩΩÂπ∂ÂÆâË£Ö X1a0He CC Âêó?")
        }
        .alert("Á°ÆËÆ§ÈáçÊñ∞Â§ÑÁêÜ", isPresented: $viewModel.showReprocessConfirmAlert) {
            Button("ÂèñÊ∂à", role: .cancel) { }
            Button("Á°ÆÂÆö") {
                viewModel.isProcessing = true
                ModifySetup.backupAndModifySetupFile { success, message in
                    viewModel.isProcessing = false
                    viewModel.isSuccess = success
                    viewModel.alertMessage = message
                    viewModel.showAlert = true
                }
            }
        } message: {
            Text("Á°ÆÂÆöË¶ÅÈáçÊñ∞Â§ÑÁêÜ Setup ÁªÑ‰ª∂Âêó?")
        }
        .alert(viewModel.isSuccess ? "Êìç‰ΩúÊàêÂäü" : "Êìç‰ΩúÂ§±Ë¥•", isPresented: $viewModel.showAlert) {
            Button("Á°ÆÂÆö") { }
        } message: {
            Text(viewModel.alertMessage)
        }
        .task {
            viewModel.setupVersion = ModifySetup.checkComponentVersion()
        }
        .onReceive(NotificationCenter.default.publisher(for: .storageDidChange)) { _ in
            viewModel.objectWillChange.send()
        }
    }
}

struct DownloadSettingsView: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        GroupBox(label: Text("‰∏ãËΩΩËÆæÁΩÆ").padding(.bottom, 8)) {
            VStack(alignment: .leading, spacing: 12) {
                LanguageSettingRow(viewModel: viewModel)
                Divider()
                DirectorySettingRow(viewModel: viewModel)
                Divider()
                RedownloadConfirmRow(viewModel: viewModel)
                Divider()
                ArchitectureSettingRow(viewModel: viewModel)
            }
            .padding(8)
        }
    }
}

struct HelperSettingsView: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel
    @Binding var showHelperAlert: Bool
    @Binding var helperAlertMessage: String
    @Binding var helperAlertSuccess: Bool

    var body: some View {
        GroupBox(label: Text("Helper ËÆæÁΩÆ").padding(.bottom, 8)) {
            VStack(alignment: .leading, spacing: 12) {
                HelperStatusRow(viewModel: viewModel, showHelperAlert: $showHelperAlert,
                              helperAlertMessage: $helperAlertMessage,
                              helperAlertSuccess: $helperAlertSuccess)
            }
            .padding(8)
        }
    }
}

struct CCSettingsView: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        GroupBox(label: Text("X1a0He CCËÆæÁΩÆ").padding(.bottom, 8)) {
            VStack(alignment: .leading, spacing: 12) {
                SetupComponentRow(viewModel: viewModel)
            }
            .padding(8)
        }
    }
}

struct UpdateSettingsView: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        GroupBox(label: Text("Êõ¥Êñ∞ËÆæÁΩÆ").padding(.bottom, 8)) {
            VStack(alignment: .leading, spacing: 12) {
                AutoUpdateRow(viewModel: viewModel)
                Divider()
                AutoDownloadRow(viewModel: viewModel)
            }
            .padding(8)
        }
    }
}

struct CleanConfigView: View {
    @State private var showConfirmation = false
    @State private var showAlert = false
    @State private var alertMessage = ""
    
    var body: some View {
        GroupBox(label: Text("ÈáçÁΩÆÁ®ãÂ∫è").padding(.bottom, 8)) {
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    Button("ÈáçÁΩÆÁ®ãÂ∫è") {
                        showConfirmation = true
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.red)
                }
            }
            .padding(8)
        }
        .alert("Á°ÆËÆ§ÈáçÁΩÆÁ®ãÂ∫è", isPresented: $showConfirmation) {
            Button("ÂèñÊ∂à", role: .cancel) { }
            Button("Á°ÆÂÆö", role: .destructive) {
                cleanConfig()
            }
        } message: {
            Text("ËøôÂ∞ÜÊ∏ÖÁ©∫ÊâÄÊúâÈÖçÁΩÆÂπ∂ÁªìÊùüÂ∫îÁî®Á®ãÂ∫èÔºåÁ°ÆÂÆöË¶ÅÁªßÁª≠ÂêóÔºü")
        }
        .alert("Êìç‰ΩúÁªìÊûú", isPresented: $showAlert) {
            Button("Á°ÆÂÆö") { }
        } message: {
            Text(alertMessage)
        }
    }
    
    private func cleanConfig() {
        do {
            let downloadsURL = try FileManager.default.url(for: .downloadsDirectory, 
                                                         in: .userDomainMask, 
                                                         appropriateFor: nil, 
                                                         create: false)
            let scriptURL = downloadsURL.appendingPathComponent("clean-config.sh")
            
            guard let scriptPath = Bundle.main.path(forResource: "clean-config", ofType: "sh"),
                  let scriptContent = try? String(contentsOfFile: scriptPath, encoding: .utf8) else {
                throw NSError(domain: "ScriptError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Êó†Ê≥ïËØªÂèñËÑöÊú¨Êñá‰ª∂"])
            }
            
            try scriptContent.write(to: scriptURL, atomically: true, encoding: .utf8)
            
            try FileManager.default.setAttributes([.posixPermissions: 0o755], 
                                                ofItemAtPath: scriptURL.path)
            
            if PrivilegedHelperManager.getHelperStatus {
                PrivilegedHelperManager.shared.executeCommand("open -a Terminal \(scriptURL.path)") { output in
                    if output.isEmpty {
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                            exit(0)
                        }
                    } else {
                        alertMessage = "Ê∏ÖÁ©∫ÈÖçÁΩÆÂ§±Ë¥•: \(output)"
                        showAlert = true
                    }
                }
            } else {
                let terminalURL = URL(fileURLWithPath: "/System/Applications/Utilities/Terminal.app")
                NSWorkspace.shared.open([scriptURL], 
                                        withApplicationAt: terminalURL,
                                           configuration: NSWorkspace.OpenConfiguration()) { _, error in
                    if let error = error {
                        alertMessage = "ÊâìÂºÄÁªàÁ´ØÂ§±Ë¥•: \(error.localizedDescription)"
                        showAlert = true
                        return
                    }
                    
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        exit(0)
                    }
                }
            }
            
        } catch {
            alertMessage = "Ê∏ÖÁ©∫ÈÖçÁΩÆÂ§±Ë¥•: \(error.localizedDescription)"
            showAlert = true
        }
    }
}

private class PreviewUpdater: SPUUpdater {
    init() {
        let hostBundle = Bundle.main
        let applicationBundle = Bundle.main
        let userDriver = SPUStandardUserDriver(hostBundle: hostBundle, delegate: nil)
        
        super.init(
            hostBundle: hostBundle,
            applicationBundle: applicationBundle,
            userDriver: userDriver,
            delegate: nil
        )
    }
    
    override var automaticallyChecksForUpdates: Bool {
        get { true }
        set { }
    }
    
    override var automaticallyDownloadsUpdates: Bool {
        get { true }
        set { }
    }
}

struct LanguageSettingRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        HStack {
            Toggle("‰ΩøÁî®ÈªòËÆ§ËØ≠Ë®Ä", isOn: Binding(
                get: { viewModel.useDefaultLanguage },
                set: { viewModel.useDefaultLanguage = $0 }
            ))
                .padding(.leading, 5)
            Spacer()
            Text(getLanguageName(code: viewModel.defaultLanguage))
                .foregroundColor(.secondary)
            Button("ÈÄâÊã©") {
                viewModel.showLanguagePicker = true
            }
            .padding(.trailing, 5)
        }
        .sheet(isPresented: $viewModel.showLanguagePicker) {
            LanguagePickerView(languages: AppStatics.supportedLanguages) { language in
                viewModel.defaultLanguage = language
                viewModel.showLanguagePicker = false
            }
        }
    }

    private func getLanguageName(code: String) -> String {
        AppStatics.supportedLanguages.first { $0.code == code }?.name ?? code
    }
}

struct DirectorySettingRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        HStack {
            Toggle("‰ΩøÁî®ÈªòËÆ§ÁõÆÂΩï", isOn: $viewModel.useDefaultDirectory)
                .padding(.leading, 5)
            Spacer()
            Text(formatPath(viewModel.defaultDirectory))
                .foregroundColor(.secondary)
                .lineLimit(1)
                .truncationMode(.middle)
            Button("ÈÄâÊã©") {
                selectDirectory()
            }
            .padding(.trailing, 5)
        }
    }

    private func formatPath(_ path: String) -> String {
        if path.isEmpty { return String(localized: "Êú™ËÆæÁΩÆ") }
        return URL(fileURLWithPath: path).lastPathComponent
    }

    private func selectDirectory() {
        let panel = NSOpenPanel()
        panel.title = "ÈÄâÊã©ÈªòËÆ§‰∏ãËΩΩÁõÆÂΩï"
        panel.canCreateDirectories = true
        panel.canChooseDirectories = true
        panel.canChooseFiles = false

        if panel.runModal() == .OK {
            viewModel.defaultDirectory = panel.url?.path ?? ""
            viewModel.useDefaultDirectory = true
        }
    }
}

struct RedownloadConfirmRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        HStack {
            Toggle("ÈáçÊñ∞‰∏ãËΩΩÊó∂ÈúÄË¶ÅÁ°ÆËÆ§", isOn: $viewModel.confirmRedownload)
                .padding(.leading, 5)
            Spacer()
        }
    }
}

struct ArchitectureSettingRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel
    @EnvironmentObject private var networkManager: NetworkManager

    var body: some View {
        HStack {
            Toggle("‰∏ãËΩΩ Apple Silicon Êû∂ÊûÑ", isOn: $viewModel.downloadAppleSilicon)
                .padding(.leading, 5)
                .disabled(networkManager.loadingState == .loading)
            Spacer()
            Text("ÂΩìÂâçÊû∂ÊûÑ: \(AppStatics.cpuArchitecture)")
                .foregroundColor(.secondary)
                .lineLimit(1)
                .truncationMode(.middle)
        }
        .onChange(of: viewModel.downloadAppleSilicon) { newValue in
            Task {
                await networkManager.fetchProducts()
            }
        }
    }
}

struct HelperStatusRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel
    @Binding var showHelperAlert: Bool
    @Binding var helperAlertMessage: String
    @Binding var helperAlertSuccess: Bool
    @State private var isReinstallingHelper = false
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("Helper Áä∂ÊÄÅ: ")
                if PrivilegedHelperManager.getHelperStatus {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                    Text("Â∑≤ÂÆâË£Ö (build \(UserDefaults.standard.string(forKey: "InstalledHelperBuild") ?? "0"))")
                } else {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.red)
                    Text("Êú™ÂÆâË£Ö")
                        .foregroundColor(.red)
                }
                Spacer()
                
                if isReinstallingHelper {
                    ProgressView()
                        .scaleEffect(0.7)
                        .frame(width: 16, height: 16)
                }
                
                Button(action: {
                    isReinstallingHelper = true
                    PrivilegedHelperManager.shared.removeInstallHelper()
                    PrivilegedHelperManager.shared.reinstallHelper { success, message in
                        helperAlertSuccess = success
                        helperAlertMessage = message
                        showHelperAlert = true
                        isReinstallingHelper = false
                    }
                }) {
                    Text("ÈáçÊñ∞ÂÆâË£Ö")
                }
                .disabled(isReinstallingHelper)
                .help("ÂÆåÂÖ®Âç∏ËΩΩÂπ∂ÈáçÊñ∞ÂÆâË£Ö Helper")
            }
            
            if !PrivilegedHelperManager.getHelperStatus {
                Text("Helper Êú™ÂÆâË£ÖÂ∞ÜÂØºËá¥Êó†Ê≥ïÊâßË°åÈúÄË¶ÅÁÆ°ÁêÜÂëòÊùÉÈôêÁöÑÊìç‰Ωú")
                    .font(.caption)
                    .foregroundColor(.red)
            }
            
            Divider()

            HStack {
                Text("Helper ËøûÊé•Áä∂ÊÄÅ: ")
                PulsingCircle(color: helperStatusColor)
                    .padding(.horizontal, 4)
                Text(helperStatusText)
                    .foregroundColor(helperStatusColor)
                
                Spacer()
                
                Button(action: {
                    if PrivilegedHelperManager.getHelperStatus && 
                       viewModel.helperConnectionStatus != .connected {
                        PrivilegedHelperManager.shared.reconnectHelper { success, message in
                            helperAlertSuccess = success
                            helperAlertMessage = message
                            showHelperAlert = true
                        }
                    }
                }) {
                    Text("ÈáçÊñ∞ËøûÊé•")
                }
                .disabled(!PrivilegedHelperManager.getHelperStatus || 
                         viewModel.helperConnectionStatus == .connected ||
                         isReinstallingHelper)
                .help("Â∞ùËØïÈáçÊñ∞ËøûÊé•Âà∞Â∑≤ÂÆâË£ÖÁöÑ Helper")
            }
        }
    }
    
    private var helperStatusColor: Color {
        switch viewModel.helperConnectionStatus {
        case .connected: return .green
        case .connecting: return .orange
        case .disconnected: return .red
        case .checking: return .orange
        }
    }
    
    private var helperStatusText: String {
        switch viewModel.helperConnectionStatus {
        case .connected: return String(localized: "ËøêË°åÊ≠£Â∏∏")
        case .connecting: return String(localized: "Ê≠£Âú®ËøûÊé•")
        case .disconnected: return String(localized: "ËøûÊé•Êñ≠ÂºÄ")
        case .checking: return String(localized: "Ê£ÄÊü•‰∏≠")
        }
    }
}

struct SetupComponentRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("X1a0He CC Â§á‰ªΩÁä∂ÊÄÅ: ")
                if ModifySetup.isSetupBackup() {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                    Text("Â∑≤Â§á‰ªΩ")
                } else {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.red)
                    Text("(ÂèØËÉΩÂØºËá¥Â§ÑÁêÜ Setup ÁªÑ‰ª∂Â§±Ë¥•)")
                }
            }
            Divider()
            HStack {
                Text("X1a0He CC Â§ÑÁêÜÁä∂ÊÄÅ: ")
                if ModifySetup.isSetupModified() {
                    Image(systemName: "checkmark.circle.fill")
                        .foregroundColor(.green)
                    Text("Â∑≤Â§ÑÁêÜ")
                } else {
                    Image(systemName: "xmark.circle.fill")
                        .foregroundColor(.red)
                    Text("(Â∞ÜÂØºËá¥Êó†Ê≥ï‰ΩøÁî®ÂÆâË£ÖÂäüËÉΩ)")
                }
                Spacer()

                Button(action: {
                    if !ModifySetup.isSetupExists() {
                        viewModel.showDownloadAlert = true
                    } else {
                        viewModel.showReprocessConfirmAlert = true
                    }
                }) {
                    Text("ÈáçÊñ∞Â§ÑÁêÜ")
                }
            }
            Divider()
            HStack {
                Text("X1a0He CC ÁâàÊú¨‰ø°ÊÅØ: \(viewModel.setupVersion) [\(AppStatics.cpuArchitecture)]")
                Spacer()

                if viewModel.isDownloadingSetup {
                    ProgressView(value: viewModel.setupDownloadProgress) {
                        Text(viewModel.setupDownloadStatus)
                            .font(.caption)
                    }
                    .frame(width: 150)
                    Button("ÂèñÊ∂à") {
                        viewModel.cancelDownload()
                    }
                } else {
                    Button(action: {
                        viewModel.showDownloadConfirmAlert = true
                    }) {
                        Text("‰∏ãËΩΩ X1a0He CC")
                    }
                }
            }
        }
    }
}

struct AutoUpdateRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        HStack {
            Toggle("Ëá™Âä®Ê£ÄÊü•Êõ¥Êñ∞ÁâàÊú¨", isOn: Binding(
                get: { viewModel.automaticallyChecksForUpdates },
                set: { viewModel.updateAutomaticallyChecksForUpdates($0) }
            ))
            Spacer()
            CheckForUpdatesView(updater: viewModel.updater)
        }
    }
}

struct AutoDownloadRow: View {
    @ObservedObject var viewModel: GeneralSettingsViewModel

    var body: some View {
        Toggle("Ëá™Âä®‰∏ãËΩΩÊúÄÊñ∞ÁâàÊú¨", isOn: Binding(
            get: { viewModel.automaticallyDownloadsUpdates },
            set: { viewModel.updateAutomaticallyDownloadsUpdates($0) }
        ))
        .disabled(viewModel.isAutomaticallyDownloadsUpdatesDisabled)
    }
}


#Preview("About Tab") {
    AboutAppView()
}

#Preview("General Settings") {
    let networkManager = NetworkManager()
    VStack {
        GeneralSettingsView(updater: PreviewUpdater())
            .environmentObject(networkManager)
    }
    .fixedSize()
}
